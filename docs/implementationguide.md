# Implementation Guide
This guide will go over everything the user must know in order to implement ConnectPay's API.
## Pre-requisites
Below are the prerequisites before using ConnectPay's API:

## Connectivity

The ConnectPay services are accessed through the public Internet. ConnectPay accepts communication only via the HTTPS channel. Custom HTTP headers are also used to carry additional information in each request.
|Environment                |Host                                     |Base Path  |
|---------------------------|-----------------------------------------|-----------|
|Certification API End Point|https://cat.api.firstdata.com/gateway/v2 |/connectpay|
|Production API End Point   |https://prod.api.firstdata.com/gateway/v2|/connectpay|

## Header Description
The header of each API call will contain several parameters. It is important that each parameter contain the specified values for a successful API call. Any changes to the values will be noted throughout the guide.

### HTTP Headers
|Header Name  |Required   |Description|
|-------------|-----------|-----------|
|Api-Key      |Yes        |This is the partner API key. Refer to the Apigee portal for more details. This is the API key is used to identify the partner and to use the ConnectPay API.|
|Timestamp    |Yes        |Request initiation UTC timestamp, formatted as Epoch time. The value is in milliseconds. Sample value format is 1499961987232|
|Authorization|Optional   |Authorization header is required to have the "HMAC" string capitalized and followed by one space followed by the calculated hmac signature. For request generated through Server: Authorization: - HMAC . "HMAC " followed by the Encrypted payload as signature, shown below:|
|Content-Type |Yes        |application/JSON|
|Client-Token |Optional   |This is OAuth token generated by /v1/security/createsessiontoken ConnectPay API service. This would be sent in instead of Authorization by the SDK.|
|corelationID |Conditional (For merchants who opt for long lived public key)|For MAS to ConnectPayAPI server calls, MAS need to provide reference transaction id in the service request header for transaction tracking. If MAS fails to provide transaction id, then ConnectPayAPI will generate separate correlationID for each flow and each end-to-end transaction will have separate transaction id for each request in the transaction. Considering that one business scenario consists of multiple api calls, the reference transaction id of the first call should be populated in the subsequent calls.|
|isSecureCall |Conditional (For merchants who opt for long lived public key)|For MAS to ConnectPayAPI server calls, MAS need to provide the header with value ‘Y’. For SDK/App to ConnectPayAPI calls, the header is not required. If present, it should have value ‘N’ Any values other than Y/N will be treated as configuration error, and MAS will receive BAD REQUEST.|

### Sample Header
```
"Content-Type" : "application/json"
"Api-Key" : "YMgw8VSrYMG6WTIUnoUUGv7hF9Aqh3EO"
"Timestamp": "1607368688646"
"Authorization" : "HMAC W5X9NAlPgSNsfQX55fXbXrk3arzL6KxcCTA6SrnxL+U="
"Client-Token" : "IXwY1BYpvWpoGzete43AdLzXSdj4"
```
## How to generate HMAC Signature

### Description
The HMAC signature is used in all calls made through our API and is a necessary step to receive a successful response from the system.

### High Level Flow
1. Get the apikey or the merchant's ConnectPay FirstAPI key
2. Get and save the current UTC timestamp, to the millisecond
3. Concatenate the two paramters to output apikey:timestamp
4. Get the request payload or the actual content passed as a post request
5. Create a hash of the payload using SHA256
6. Encode the hash using Base64 to create base64ofPayloadDigest
7. Concatenate apikey:timestamp with base64ofPayloadDigest to create apikey:timestamp:base64ofPayloadDigest
8. Get the apiSecret or the merchant's ConnectPay FirstAPI secret
9. Create the HMAC value using HMAC SHA256, apikey:timestamp:base64ofPayloadDigest, and the apiSecret as the secret for the HMAC SHA256 calculation
10. Encode the new HMAC value using Base64 to create the signature
11. Append the signature to HMAC followed by a space to create "HMAC Signature"
12. The "Authorization" header = HMAC signature

Below is sample code on how to create the "Authorization" header:
```java
import java.security.MessageDigest;
import javax.crypto.Mac;
import javax.crypto.spec.SecretKeySpec;
import org.apache.commons.codec.binary.Base64;
public class HmacUtil {
    private static final String CT_CLN = ":";
    private static final String MD_ALG = "SHA-256";
    private static final String HMAC_ALG = "HmacSHA256";
    public static String generateHmac(String apiKey,
    String apiSecret,String epochTimestamp, String payload) throws Exception {
        byte[] hash = MessageDigest.getInstance(MD_ALG).digest(payload.getBytes());
        String encPyld = Base64.encodeBase64String(hash);
        String messageToSign = apiKey + CT_CLN + epochTimestamp + CT_CLN + encPyld;
        Mac hmac = Mac.getInstance(HMAC_ALG);
        SecretKeySpec key = new SecretKeySpec(apiSecret.getBytes(), HMAC_ALG);
        hmac.init(key);
        return Base64.encodeBase64String(hmac.doFinal(messageToSign.getBytes()));
    }
}
```
## Encryption & Decryption Methodologies 
Most of the ConnectPay APIs need to be encrypted prior to making a request. The methodologies are discussed below with example code on the actual methods in Java. We will use these methods later in order to generate and encrypt the payloads.

<details>
<summary>1. AES Key and IV Generation</summary>
<br>
<span style="font-size: 1.25em; color: var(--bs-heading-color)">
AES Key
</span> 

The AES Key generated must be size 256-bit in order for the Fiserv systems to decrypt the request payload. <p>

<span style="font-size: 1.25em; color: var(--bs-heading-color)">
IV
</span> 

The IV generated must be size 96-bit in order for the Fiserv systems to decrypt the request payload.

<span style="font-size: 1.25em; color: var(--bs-heading-color)">
Key Generator
</span> 

The AES Key and IV will be used to encrypt the actual request payload. Below is sample code on how to generate the merchant's AES key and IV:
```java
private static final char[] HEX_ARRAY = "0123456789abcdef".toCharArray(); 

private String randomHexString(int size) { 
    SecureRandom random = new SecureRandom(); 
    byte[] iv = new byte[count / 8]; 
    random.nextBytes(iv); 
    return bytesToHex(iv); 
} 

public static String bytesToHex(byte[] bytes) { 
    char[] hexChars = new char[bytes.length * 2]; 
    for (int j = 0; j < bytes.length; j++) { 
        int v = bytes[j] & 0xFF; 
        hexChars[j * 2] = HEX_ARRAY[v >>> 4]; 
        hexChars[j * 2 + 1] = HEX_ARRAY[v & 0x0F]; 
    } 
    return new String(hexChars); 
} 
```
</details>

<details>
<summary>2. AES Encryption and Decryption</summary>
<br>
The merchant must implement methods for AES encryption in order to encrypt the payload prior to making a call. <p>

<span style="font-size: 1.25em; color: var(--bs-heading-color)">
AES Specification
</span>

| Type | Value            | 
|------|------------------|
|ALGO  |AES               | 
|CIPHER| AES/GCM/NoPadding|

<span style="font-size: 1.25em; color: var(--bs-heading-color)">
AES Encryption
</span> 

AES Encryption will be used to encrypt the actual payload using the AES Key and IV generated before. Below is sample code on how to encrypt using AES:
```java
public class AesUtil {
    private static final String ALGO = "AES";
    private Cipher cipher = null;
    private SecretKey secretKey = null;
    private String initializationVector = null;
    private String correlationId = null;

    public static final int GCM_TAG_LENGTH_BIT = 128;
    private static final int IV_LENGTH_BYTE = 12;

    /**
    * Initialize cipher with IV and secret key
    */
    public void init(String encKey, String initializationVector, String correlationId) throws Exception {
        try {
            cipher = Cipher.getInstance(PartnerAlgo.AES_GCM_NoPadding.getValue());
        } catch (NoSuchAlgorithmException | NoSuchPaddingException e) {
            LOG.error("Exception in AesUtil.init {}", e);
            throw e;
        }
        this.secretKey = generateKey(encKey);
        this.initializationVector = initializationVector;
        this.correlationId = correlationId;
    }

    /**
    * encryption with secret key, IV and salt (IV value)
    */
    public String encrypt(String clearText, String correlationId) throws Exception {
        if (this.correlationId == null)
            this.correlationId = correlationId;
        try {
            byte[] encrypted = doFinal(Cipher.ENCRYPT_MODE, secretKey, initializationVector,
                clearText.getBytes("UTF-8"));
            byte[] IV_BYTES = hex(initializationVector);
            byte[] cipherTextWithIv = ByteBuffer.allocate(IV_BYTES.length + encrypted.length).put(IV_BYTES)
                .put(encrypted).array();
            return base64(cipherTextWithIv);
        } catch (UnsupportedEncodingException e) {
            LOG.error("Exception in AesUtil.encrypt {}", e);
            throw e;
        } catch (Exception e) {
            LOG.error("Exception in AesUtil.encrypt {}", e);
            throw e;
        }
    }

    private SecretKey generateKey(String encKey) {
        try {
            SecretKey key = new SecretKeySpec(hex(encKey), ALGO);
            return key;
        } catch (NumberFormatException | DecoderException e) {
            LOG.error("Exception in AesUtil.generateKey {}", e);
            return null;
        }
    }

    private byte[] doFinal(int encryptMode, SecretKey key, String iv, byte[] bytes) throws Exception {
        cipher.init(encryptMode, key, new GCMParameterSpec(GCM_TAG_LENGTH_BIT, hex(iv)));
        return cipher.doFinal(bytes);
    }
}
```

<span style="font-size: 1.25em; color: var(--bs-heading-color)">
AES Decryption
</span>

The AES decryption method will be used to decode the response payload using the AES key and IV once the process is complete. Below is sample code on how to decrypt using RSA:

```java
public class AesUtil {
    private static final String ALGO = "AES";
    private Cipher cipher = null;
    private SecretKey secretKey = null;
    private String initializationVector = null;
    private String correlationId = null;

    public static final int GCM_TAG_LENGTH_BIT = 128;
    private static final int IV_LENGTH_BYTE = 12;
    
    /**
    * Initialize cipher with IV and secret key
    */
    public void init(String encKey, String initializationVector, String correlationId) throws Exception {
        try {
            cipher = Cipher.getInstance(PartnerAlgo.AES_GCM_NoPadding.getValue());
        } catch (NoSuchAlgorithmException | NoSuchPaddingException e) {
            LOG.error("Exception in AesUtil.init {}", e);
            throw e;
        }
        this.secretKey = generateKey(encKey);
        this.initializationVector = initializationVector;
        this.correlationId = correlationId;
    }

    /**
    * Decryption with secret key, IV and salt (IV value)
    */
    public String decrypt(String ciphertext) throws Exception {
        try {
            ByteBuffer buffer = ByteBuffer.wrap(base64(ciphertext));
            byte[] iv = new byte[IV_LENGTH_BYTE];
            buffer.get(iv);
            byte[] extractedCipherText = new byte[buffer.remaining()];
            buffer.get(extractedCipherText);
            byte[] decrypted = doFinal(Cipher.DECRYPT_MODE, secretKey, initializationVector, extractedCipherText);
            return new String(decrypted, "UTF-8");
        } catch (UnsupportedEncodingException e) {
            LOG.error("Exception in AesUtil.decrypt {}", e);
            throw e;
        } catch (Exception e) {
            LOG.error("Exception in AesUtil.decrypt {}", e);
            throw e;
        }
    }

    private SecretKey generateKey(String encKey) {
        try {
            SecretKey key = new SecretKeySpec(hex(encKey), ALGO);
            return key;
        } catch (NumberFormatException | DecoderException e) {
            LOG.error("Exception in AesUtil.generateKey {}", e);
            return null;
        }
    }

    private byte[] doFinal(int encryptMode, SecretKey key, String iv, byte[] bytes) throws Exception {
        cipher.init(encryptMode, key, new GCMParameterSpec(GCM_TAG_LENGTH_BIT, hex(iv)));
        return cipher.doFinal(bytes);
    }
}
```
</details>

<details>
<summary>3. RSA Encryption and Decryption</summary>
<br>
The merchant must implement RSA Encryption in order to encrypt the AES key and IV using the RSA "publicKey" generated from the "Create Session Token" API.

<span style="font-size: 1.25em; color: var(--bs-heading-color)">
RSA Specification
</span>

| Type | Value                               | 
|------|-------------------------------------|
|ALGO  |RSA                                  | 
|CIPHER|RSA/None/OAEPwithSHA512AndMGF1Padding|

<span style="font-size: 1.25em; color: var(--bs-heading-color)">
RSA Encryption
</span>

RSA will be used to encrypt Components X and Y which are the AES Key and IV respectively. These are encrypted using the RSA public key obtained from the Create Session Token API. Below is sample code on how to encrypt using RSA:
```java
private static final String ALGORITHM = "RSA";  
public static String encrypt(byte[] publicKey, String inputData, String rsaAlgoType) throws Exception { 

    LOG.info("Start Encrypt"); 

    // Provider added for new algorithm (RSA/None/OAEPWithSHA512AndMGF1Padding) support 
    Security.addProvider(new org.bouncycastle.jce.provider.BouncyCastleProvider()); 

    X509EncodedKeySpec ks = new X509EncodedKeySpec(publicKey); 
    KeyFactory kf = KeyFactory.getInstance(ALGORITHM); 
    PublicKey key = kf.generatePublic(ks); 
    Cipher cipher = getCipher(rsaAlgoType); 
    cipher.init(Cipher.ENCRYPT_MODE, key); 
    byte[] cryptogram = cipher.doFinal(inputData.getBytes()); 
    final String encValue = new String(Base64.encodeBase64(cryptogram)); 
    return encValue; 
} 
```
<span style="font-size: 1.25em; color: var(--bs-heading-color)">
RSA Decryption
</span>

Below is sample code on how to decrypt using RSA however, the Merchant may not need decryption methods for RSA since the Fiserv backend will decrypt the request payload in order to process the request. The merchant may still want to decrypt the request payload based on a variety of different factors. Below is a sample code on how to decrypt using RSA:
```java
private static final String ALGORITHM = "RSA";  
public static String decrypt(byte[] privateKey, String inputData,String rsaAlgoType) throws Exception { 
    LOG.info("Start Decrypt"); 
    PrivateKey key = KeyFactory.getInstance(ALGORITHM).generatePrivate(new PKCS8EncodedKeySpec(privateKey)); 
    Cipher cipher = getCipher(rsaAlgoType); 
    cipher.init(Cipher.DECRYPT_MODE, key); 
    byte[] decryptedBytes = cipher.doFinal(Base64.decodeBase64(inputData)); 
    LOG.info("End Decrypt"); 
    return new String(decryptedBytes, "UTF-8"); 
} 
```
</details>

## How to Utilize API
This section will guide the developer on how to implement one of ConnectPay's APIs. We will use the "Add Consumer Profile" API for this example as well as the "Create Session Token" API as it is a mandatory substep to use most of ConnectPay's API.

###  Step 1: Create Session Token
<p>
The Create Session Token API call is used to create a session token and to retrieve the RSA public key. This API is secured as it requires the Authorization header that can only be derived using the API Secret stored in the Merchant’s server. Below is more information on the API specification as well as example request and response payloads. <p>

[![](/assets/images/button.png '')](https://qa-developer.fiserv.com/product/ConnectPay/api/?type=post&path=/security/createsessiontoken&branch=develop&version=1.0.0)


Example Request Payload:

Use the payload below to create the Authorization Header.
```json
{
  "security": {
    "publicKeyRequired": true
  }
}
```

Example Response Payload:
```json
{
    "transactionStatus": "APPROVED",
    "transactionStatusCode": 0,
    "referenceTransactionID": "bedceb8b-2445-b1d5-4c1e-c09446099023",
    "transactionStatusDescription": "OK",
    "security": {
        "tokenID": "0HMxmsoYJRfAiGdxEsjcso3K8uY6",
        "issuedOn": "1583174178590",
        "expiresInSeconds": "599",
        "publicKey": "MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEArAhyMQmqTL798rKAixN9jtnp4SFF5PVpqc/HKNprSSoaANsnpJLSTRLFMCuQIa2dcgFZM+nSPvSCGowD65/tMWBHTWfeXiSV1xWmhPdEQRocmUaRp3HoEO3RU1n5os9jQLMGEcyxopgtTvUydJSrjLWNGcC9UC50HIEBEOBqycRvqlI/oRO1oBIx8UPAe/dGKTO8Bx8f6J4Lyi5ilW0gFFYSni/Krg/fMrxu6luyGmBOr2H9zy6fv+8dLQd0LEoOAaZ/2RLfcTPnheyV7eUOvOS4DGISiQBRpXyu9Zlo1B3GbiXX8NkfCo2ByDq+6gELji7Tr+gT+zuj+5H12eQIDAQAB",
        "algorithm": "RSA/None/PKCS1Padding",
        "status": "ACTIVE"
    }
}
```
### Step 2: Create & Request Payload
At this step, all prerequisites have been complete in order to make our first call. First, the request payload must be created. The entire payload must be encrypted using different encryption methods. It must also be decrypted in order to decode the response payload into something that is readable. We will use the "Add Consumer Profile" as the example API. 

> Note: We will need to use the "tokenID" for the "Client-Token" header as well as the RSA "publicKey" in order to encrypt a portion of the payload before making the API call. Save these two pieces of information from the "Create Session Token" API used earlier in order to complete the call.


#### Add Consumer Profile
The Create Consumer Profile call is mandatory for any new user enrollment. This is used to create an fdCustomerID for a provided external id (and other user information) by the merchant. <p>

[![](/assets/images/button.png '')](https://qa-developer.fiserv.com/product/ConnectPay/api/?type=post&path=/consumerprofile/add&branch=develop&version=1.0.0)

#### Create Request Payload
First and foremost, we need to create the request payload prior to encryption. The "externalID" can be whatever the developer would like. It is a unique identifier for each consumer and the should be incremented with each unique consumer. An example payload is shown below:
```json
{
    "customer": {
        "externalID": "Merchant01Customer00000000"
    }
}
```

>Note: We need to next create the HMAC Authorization header using the payload above. The Authorization header and HMAC methodology is discussed earlier in the prerequisite section.

#### Encrypt the AES key and IV
From above prerequisites section, we implemented the methodology to create the AES key and IV. We will use the publicKey generated from the "Create Session Token" API in order to encrypt the generated AES Key as "componentX" and the IV as "componentY". An example of the encrypted input is shown below:
```json
    "componentX": "ju5PPi7k4K2jtI0z47qKcHnQGRrIymN+dK+PVlWjKyufoaUHJqjqOAbjsQZ0q3sLciBkEVWm5jGbWQoGf2e9Us+yfYu8ua2hz3wOIRSymHdx8qKuoexQiKhLWnp/GAL0+TIdzb/CvNijuJkOe1XSzEoFdFjYgRNMV8LJM3G/izn48kZm9gexM/iJenJyzwFoqXJc7EcWrC3C0RlkBF5jTgZzTGCvBpxDq4pw3CjFDsGvFy5Gg26B1KRcRDctrFpLV697QAW//hWyS91NYB68S3TIo/B6/LfUjj9bOY3fM+i+5BY2oV7zbLLyvA+CKfLFRBoXtevfBJyndrUDFD0EBA==",
    "componentY": "CqTTfUbNR66rGRhAKGqnEYJBGona07l2lvV7s7sEG97b0eohkWCqcw/XhCSy2+A6rYxhhuvvQ+orjfmCzssIl4Uz+4gu3GE3lfMGeykjRuhipyV+fjnjOBcw/VDOg3IXffr4Oe/isRYTZ5gp0uht89Rpu9VXfWktKH5uEJiZdNyD9TY+xZ2Ekwc6trDjTSFPbxVNaITJGqMBFsuWXGcHvaqoo6bC7Q9r/pVsUHq5KDdoi0zuW+xBilMxk/hZE8fBifXkUZ+KGGibyHlseh/uH9U32UHgvyVSsiUjI1j44WNulRnvfN7Mi5HozJTiYbX2iGrL5QQLKkQIWQPWV37VgQ=="
```

#### Encrypt The Request Payload
Using the AES key and IV we will then encrypt the request payload using the AES encryption method. An example of the encrypted input is shown below:
```json
"componentDelta": "OEIyAAUL1Py3/oKewtNXswtkYOw+krJP0EFhucFWFXSug0TCV7kqL67Mk5PTzVqNWTAyPl0lK6ac2EBK3kxskC6WpzpJI4qSv7/9JSfQ7zAYUiKAKPobIXpHAJ7BuHSMlMkv/6UTJvdIRsgDaqfAbD5pqG5KDbRzXpzmLIpVJnGyPCkwwm+F36wGbe1ccuvzDHNL77e6XSmm2LpzO/NAGJRjMGXdLQ9XKFvjr/gK0ruO2gdqglomlvy3MG8BSvLCAYkOL1CAB4wF8ovsfpOAAV92KRdqxeMISntCc0/Fxg7fs9JILmn4ZkgiSgha1CsN"
```

#### Finalize the Request Payload
Using the newly encrypted data, we can then create the JSON that will be used in the request call. An example of the input is shown below:
```json
{
    "componentX": "ju5PPi7k4K2jtI0z47qKcHnQGRrIymN+dK+PVlWjKyufoaUHJqjqOAbjsQZ0q3sLciBkEVWm5jGbWQoGf2e9Us+yfYu8ua2hz3wOIRSymHdx8qKuoexQiKhLWnp/GAL0+TIdzb/CvNijuJkOe1XSzEoFdFjYgRNMV8LJM3G/izn48kZm9gexM/iJenJyzwFoqXJc7EcWrC3C0RlkBF5jTgZzTGCvBpxDq4pw3CjFDsGvFy5Gg26B1KRcRDctrFpLV697QAW//hWyS91NYB68S3TIo/B6/LfUjj9bOY3fM+i+5BY2oV7zbLLyvA+CKfLFRBoXtevfBJyndrUDFD0EBA==",
    "componentY": "CqTTfUbNR66rGRhAKGqnEYJBGona07l2lvV7s7sEG97b0eohkWCqcw/XhCSy2+A6rYxhhuvvQ+orjfmCzssIl4Uz+4gu3GE3lfMGeykjRuhipyV+fjnjOBcw/VDOg3IXffr4Oe/isRYTZ5gp0uht89Rpu9VXfWktKH5uEJiZdNyD9TY+xZ2Ekwc6trDjTSFPbxVNaITJGqMBFsuWXGcHvaqoo6bC7Q9r/pVsUHq5KDdoi0zuW+xBilMxk/hZE8fBifXkUZ+KGGibyHlseh/uH9U32UHgvyVSsiUjI1j44WNulRnvfN7Mi5HozJTiYbX2iGrL5QQLKkQIWQPWV37VgQ==",
    "componentDelta": "OEIyAAUL1Py3/oKewtNXswtkYOw+krJP0EFhucFWFXSug0TCV7kqL67Mk5PTzVqNWTAyPl0lK6ac2EBK3kxskC6WpzpJI4qSv7/9JSfQ7zAYUiKAKPobIXpHAJ7BuHSMlMkv/6UTJvdIRsgDaqfAbD5pqG5KDbRzXpzmLIpVJnGyPCkwwm+F36wGbe1ccuvzDHNL77e6XSmm2LpzO/NAGJRjMGXdLQ9XKFvjr/gK0ruO2gdqglomlvy3MG8BSvLCAYkOL1CAB4wF8ovsfpOAAV92KRdqxeMISntCc0/Fxg7fs9JILmn4ZkgiSgha1CsN"
}
```

#### Make The Request
Using the correct endpoint, headers, and encrypted payload, we can then make the call. The ConnectPay backend will decrypt the payload and process the request. It will then return the response encrypted with the AES key and IV provided by componentX and componentY. An example of the output is shown below:
```json
{
"componentDelta": "cRD5xVaJab13iRQ7l6No6ot9YPTFT3bi/qapHYGgsNmxQ8nT2mtIz7uLLHz5kdp5JEmDjiP1dXMNPg8jP5rIZQf/5dtMfFLq7YL7FQY/boTsd7BoJg7reDeeAk6l9+76gaSAZMIRJGYS4fhy1bgClx2jIeWo4fLlfildeHnghCU1ElR8XhFi3oyd8hU+YEpDENP5IJJMVxjnYChuFX8paVy/SAYFMESBXSTIgPi6Y/kJc/bswlxaa9Yei4GnD+Ny1laVs4HqJp32JJ+NHJIYdZr5117AY0JJxJ9oudnkK6J8oPnnXhLCBGxNCRDJG3AVLRxDnQcds/cSiwAVREHr4nn848IEsUb27wJR7SiDxVaELxme9CNZ1dB0tPYQ1wux3ymWtnUgLfVRFsHH3EeucbHv8uIc8dxcwxZReROzVS8="
}
```

#### Decrypt the Response Payload
Decrypt ComponentDelta with the AES Key and IV generated earlier in order to decode the response payload into a readable form. An example of the decrypted output is shown below:
```json
{
    "transactionStatus": "APPROVED",
    "transactionStatusCode": 0,
    "referenceTransactionID": "5cdd1d99-5367-ed98-56fd-3f52ab008ac8",
    "transactionStatusDescription": "Created",
    "customer": {
        "fdCustomerID": "CP1GWQ15714280477520000262L7Wymj",
        "externalID": "Merchant01Consumer65746635"
    }
}
```

#### Verify Success of the Response Payload
Verify that the transaction was successful. As shown above, the transaction was approved and we can then move to using another ConnectPay API in order to complete consumer enrollment.

Congratulations, you have successfully used ConnectPay's API. The steps above apply to all ConnectPay API's except for the "Create Session Token" API and the "Get Public Key Service" API. These APIs do not need the request payload to be encrypted prior to making a call. Please repeat steps 1 and 2 for the API below to complete an ACH transaction.

### Step 3: Consumer Enrollment
There are two ways to enroll customers. The steps for either enrolling consumers through online bank login or manual enrollment are listed below. It is also possible to have both types of enrollment methods as part of the merchant application. 

<!--
type: tab
titles: Online Bank Login, Manual Enrollment
-->

### Step 3 Option 1: Online Bank Login


<span style="font-size: 1.25em; color: var(--bs-heading-color)">
Option 1: Online Bank Login
</span>

The online bank login is used when the end-user/consumer would like to login using their banking credentials in order to link their bank account to a payment method.
<details>
<summary>Step a: Establish Online Bank Login</summary>
<br>
Use this as the first step in online bank login process. The output from this service needs to be passed to online bank login processor to initiate the bank login IFRAME.<p>

[![](/assets/images/button.png ''))](https://qa-developer.fiserv.com/product/ConnectPay/api/?type=post&path=/onlinebanklogin/establish&branch=develop&version=1.0.0)
</details>

<details>
<summary>Step b: Validate Online Bank Login</summary>
<br>
Use this method to after consumer has completed bank selection process, to pull all consumer information available on bank records to be displayed on consumer’s screen Consumer can view and edit the enrollment form prepopulated with the data from above step. Bank information is the only set of fields which should be not editable. <p>

[![](/assets/images/button.png ''))](https://qa-developer.fiserv.com/product/ConnectPay/api/?type=post&path=/onlinebanklogin/validate&branch=develop&version=1.0.0)
</details>
<details>
<summary>Step c: Consumer Enrollment</summary>
<br>
The Consumer Enrollment call is for any new consumer enrollment purpose. This is used to perform a ConnectPay enrollment process for a provided consumer details payload. This API is secured, as it requires the Authorization header that can only be derived using the API Secret stored in the Merchant’s web server. <p>

[![](/assets/images/button.png ''))](https://qa-developer.fiserv.com/product/ConnectPay/api/?type=post&path=/consumerprofile/enrollment&branch=develop&version=1.0.0)
</details>

<!--
type: tab
-->

<span style="font-size: 1.25em; color: var(--bs-heading-color)">
Option 2: Manual Enrollment
</span>

The manual enrollment is used when the end-user/consumer does not want to login with their bank credentials and would rather deposit smaller amounts using information such as the bank routing and account number.
<details>
<summary>Step a: Consumer Enrollment</summary>
<br>
The Consumer Enrollment call is for any new consumer enrollment purpose. This is used to perform a ConnectPay enrollment process for a provided consumer details payload. This API is secured, as it requires the Authorization header that can only be derived using the API Secret stored in the Merchant’s web server. <p>

[![](/assets/images/button.png ''))](https://qa-developer.fiserv.com/product/ConnectPay/api/?type=post&path=/consumerprofile/enrollment&branch=develop&version=1.0.0)
</details>

<details>
<summary>Step b: Micro-Deposit Validation</summary>
<br>
Use this method to complete micro deposit validation to authenticate your bank account after a manual enrollment.ConnectPayAPI Direct Integration Guide. Kindly note it might take a few days for the micro deposits to appear on your bank account. Once bank account is successfully authenticated, the ACH payment option gets activated for transaction. For MAS to ConnectPayAPI Server call, MAS needs to pass the fdAccountID in payload request. <p>

[![](/assets/images/button.png '')]()
</details>

<!-- type: tab-end -->


### Step 4: ACH Transactions
These APIs are for the merchant to implement depending on the use case of the end-user/consumer. These API's are exclusively used for some form of processing ACH transactions.
<details>
<summary>Purchase</summary>
<br>
Merchants who want to process ACH Transactions through FirstAPI must make server-to-server calls and pass necessary encrypted payload as required for that particular case. Use this to initiate purchase/sale transaction request where final amount is known. <p>

[![](/assets/images/button.png '')](https://qa-developer.fiserv.com/product/ConnectPay/api/?type=post&path=/transaction/purchase&branch=develop&version=1.0.0)
</details>

<details>
<summary>Authorize</summary>
<br>
Merchants who want to process ACH Transactions through FirstAPI must make server-to-server calls and pass necessary encrypted payload as required for that particular case. Use this to initiate purchase/sale transaction request where final amount is known. <p>

[![](/assets/images/button.png '')](https://qa-developer.fiserv.com/product/ConnectPay/api/?type=post&path=/transaction/authorize&branch=develop&version=1.0.0)
</details>


>You have successfully completed an ACH transaction. For information on other ConnectPay APIs, please look below for the API specification:


### Other APIs:
For more information on the other APIs within ConnectPay please visit the API Explorer on the navigation bar on the left.

### Useful Artifacts to help you Integrate
[//]: <> (Need to link below to the actual files)
- [SDK](https://qa-developer.fiserv.com/product/ConnectPay/docs/?path=./documentation/connectpaysdklanding.md&branch=develop)

